![](https://valerio65.github.io/assets/img/gassert.png )
<center>

V. Terragni, G. Jahangirova, P. Tonella, M. Pezzè.  
Università della Svizzera italiana (USI), Lugano, Switzerland 
</center>



## Requirements

* 		JDK 1.8
* 	 	Unix or MAC OS X operating systems


## Installation Instructions

Unzip `GAssert.zip`, please maintain the same name of the root folder `GAssert` otherwise the bash scripts will not work. All the libraries required by GAssert are already included inside the zip. 

First you need to set the `JAVA_HOME` environmental variable.
Go inside the `scripts` folder and open `init_environment.sh`.
You can set the `JAVA_HOME` at line 5.

For example: `    export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home"`

> **We require JDK 1.8** because some of the libraries we used require JDK 1.8, we did not test the tool on newer/older JDKs. If you don't have JDK 1.8 installed on your computer, you can download it for free from here [https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html](https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html) 

Then, you need to instrument the JDK for [DAIKON](https://plse.cs.washington.edu/daikon/).
From the command line change directory :

	cd libs/daikon-5.7.2/java
	
be sure that in the command line the variable `JAVA_HOME` is properly set. You can set the variable like you did in the script:

	export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home"

	
instrument the JDK like this

	make dcomp_rt.jar

after few minutes you should see the following output

	Processed 20500/20690 classes at Thu Jun 04 15:33:29 CEST 2020
	Processed 20600/20690 classes at Thu Jun 04 15:33:30 CEST 2020
	Found 15635 statics
	Writing all classes to dcomp-rt/java/lang/jdk_classes.txt
	No methods were skipped.
	done at Thu Jun 04 15:33:32 CEST 2020
	jar cmf dcomp-rt/META-INF/MANIFEST.MF dcomp_rt.jar -C dcomp-rt .

If you have problem to compile [DAIKON](https://plse.cs.washington.edu/daikon/), please refer to the [troubleshooting of Daikon](https://plse.cs.washington.edu/daikon/download/doc/daikon.html#Troubleshooting)


## Test Your Installation (basic usage example)

To test your installation, you can run GASSERT on one of our subjects. Go inside the scripts folder and invoke the script ` ./run_gassert.sh`. The scripts takes in input 4 parameters

* TOOL (it can be either GASSERT, RANDOM or DAIKON)
* subjectFolder (the folder name of the subject inside the subjects folder)
* timeBudget (in minutes for the oracle improvement, a reasonable time budget is not less than 10 minutes)
* fileNameAssertionInInput (the name of the file inside the subject's `input-assertions` folder)

For example:

	 cd GAssert/scripts
	 ./run_gassert.sh GASSERT simple-examples_getMin 10 human.assertions

It will run GASSERT for our running example (see Section 3.1 in the paper).
More specifically, it runs GASSERT for the subject `subjects\simple-examples_getMin`, which refers to a method that returns the minimum between two integers.
GASSERT will run with a time budget of 10 minutes and with the assertion in input found in the file `subjects\simple-examples_getMin\input-assertions\human.assertions` (i.e., `assert(result > b)'). 

The run will comprise of three phases: collection of the initial correct and incorrect states (PHASE 1), the oracle improvement process (PHASE 2), and the evaluation of the resulting assertion (PHASE 3).

***
### Phase 1 - collection of the initial correct and incorrect states

Note that the time budget refers only to the evolutionary process, it excludes the time spent for Phase 1, which may take from 10 to 20 minutes.
This phase will use [Randoop](https://randoop.github.io/randoop/) to generate the validation tests and [Evosuite](https://github.com/EvoSuite/evosuite) to generate the initial tests.
The script executes the initial tests with a version of the method under test without the assertion, to collect a set of correct states.
Then the initial tests will be executed on mutants generated by [Major](http://mutation-testing.org/downloads/) to collect the initial set of incorrect states. Finally, [DAIKON](https://plse.cs.washington.edu/daikon/) will generate an invariant for the assertion point, which can be used as an input of GAssert.

We now describe in details the behaviour of the script and the expected behaviour for Phase 1.


If the setup is correct, you should see the following output

	generating the initial sets of correct and incorrect states   
	- Use Randoop to generate Tests for class: SimpleMethods.java seed:    
	PUBLIC MEMBERS=7   
	Explorer = ForwardGenerator(allSequences:0, sideEffectFreeMethods:1119, subsumed_sequences:0, runtimePrimitivesSeen:38)

Then Randoop will execute 10 times obtaining a maximum number of 1000 tests for the validation. You should find the generated tests inside `subjects\simple-examples_getMin\randoop-evaluation-tests`

Then [Major](http://mutation-testing.org/downloads/) will generate a series of mutants for the method under test

	- Use Major to generate Mutants for class SimpleMethods.java

You should find the mutants of the method under tests in the folder `subjects\simple-examples_getMin\initial-mutations`


Then [Evosuite](https://github.com/EvoSuite/evosuite) will run 10 times to generate additional tests

	- Use Evosuite to generate Tests for class: SimpleMethods.java LATEST VERSION
	* EvoSuite 1.0.6
	* Going to generate test cases for class: examples.SimpleMethods
	* Starting client
	* Connecting to master process on port 9922
	* Analyzing classpath: 


You should find the initial Evosuite tests in `subjects\simple-examples_getMin\evosuite-initial-tests`


Then you will see a series of gradle build failure/success. This is an expected behaviour because the script will run the generated tests on the mutants to collect the sets of incorrect states. Since the mutations might lead to failures, seeing build failures is normal.


	* Try:
	Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.
	BUILD FAILED in 1s
	3 actionable tasks: 3 executed
	failing tests in file
	[examples.SimpleMethodsInit_1_ESTest.test01, examples.SimpleMethodsInit_1_ESTest.test02, 	examples.SimpleMethodsInit_1_ESTest.test03]
	:compileJava
	:processResources NO-SOURCE
	:classes
	:compileTestJava
	:processTestResources NO-SOURCE
	:testClasses
	:test
	Results: SUCCESS (3 tests, 3 successes, 0 failures, 0 skipped)

After [DAIKON](https://plse.cs.washington.edu/daikon/) will generate an invariant for the method under test. You can find the invariant in the file `subjects\simple-examples_getMin\initial-assertions\daikon.assertions`

	RUN DAIKON
	Daikon version 5.7.2, released November 7, 2018; http://plse.cs.washington.edu/daikon.
	Reading declaration files Processing trace data; reading 1 dtrace file:
	============================================
	examples.RunAllTests.main(java.lang.String[]):::ENTER
	args != null
	args.getClass().getName() == java.lang.String[].class.getName()
	("oneOf.java.jpp: SEQUENCE unimplemented" != null)
	daikon.Quant.pairwiseEqual(daikon.Quant.collectObject(args, "toString()"), new String[] {  })
	=================================================
	examples.RunAllTests.main(java.lang.String[]):::EXIT

Then Phase 1 terminates, the collected program states are stored on the disk inside the folder `initial-states` inside the subject folder.

***
### Phase 2 - Oracle improvement process

Now the actual oracle improvement process will start. The time budget will be divided in 3 to allow for at least 2 iterations with the oracle assessor (see paper for the details).

You should see the following output at console:

	time budget minutes single evo:  3
	 START TOOL: GASSERT SEED: 0 BUDGET: 10  class: examples.SimpleMethods methodName: 
	- Use Randoop to generate Tests for class: SimpleMethods.java seed: 

Randoop will start again to allow dynamic analysis which is needed for preparing the subject.

Then, the evolutionary process will start by collecting the states and variables:

	2020-06-03 17:06:48,329 .<init>(EvolutionaryAlgorithm.java:56)     
	 START GASSERT 
 
	2020-06-03 17:06:48,429 .logInfo(TestExecutionStates.java:155)     
	 number of tests |T|= ... 
	 
	2020-06-03 17:06:48,429 .logInfo(TestExecutionStates.java:156)     
	 number of mutants |M|= ... 
	 
	2020-06-03 17:06:48,429 .logInfo(TestExecutionStates.java:159)     
	 number of mutant tests |M||T|= .. 
	 
	size correct states ... size incorrect states..
	2020-06-03 17:06:48,432 .load(VariableManager.java:60)     
	 boolean variables that will be considered 0 [] 
	 
	2020-06-03 17:06:48,432 .load(VariableManager.java:61)     
	 number variables that will be considered 5 [result, a, b, old_b, old_a] 
	 
	2020-06-03 17:06:48,433 .run(EvolutionaryAlgorithm.java:70)     
	 start initialization population 
	 
	initial assertions [result < a]

Then you will see a summary for every 10 generations, showing the fittest solution. That is, the assertion with the lowest number of FP, FN, and lowest complexity. For example,

	# generation:              10
	time cost:                 00:00:03.689
	average time cost:         00:00:00.368
	AssertionManager cached assertions:          12659
	CPU load:                  3.7509765625
	# running threads:                  12
	Memory heap used:          408
	best so far(((old_a > a) || (result <= old_b)) && ((result == (old_b * a)) || (result == old_a)))
	(((old_a > a) || (result <= old_b)) && ((result == (old_b * a)) || (result == old_a)))
	fitnessValueFP=0.0
	fitnessValueFN=0.09090909090909091
	complexity=17
	type=BOOLEAN
	idsFNGOOD[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	idsFPGOOD[0, 1, 2, 3, 4, 5]

This assertion has zero false positive but has 0.090 false negatives.

If GASSERT finds an assertion with zero FP and zero FN and it has executed for at least 100 generations, it will stop.

Then it will start the iteration 1 and invoke the oracle assessor [OASIs](https://github.com/guneljahan/OASIs) for collecting evidence of false positives and false negatives


	============ ITERATION ========== 1
	...
	running OASIS - FALSE NEGATIVE
	...
	FN? true
	...
	running OASIS - FALSE POSITIVE
	...
	FP? true

If it finds evidence it will run again GASSERT to improve the assertion returned by the previous iteration. Now inside the `states` there will be the new correct and incorrect states produced by OASIs that will help GASSERT to converge to a better assertion.

This iterative process continues until the time budget expires or the oracle assessor OASIs cannot find any evidence of FP and FN.

For example, this can be the final assertion

	assert((((result == old_b) || (old_a == result)) && ((result <= old_a) && (result <= old_b)))); 

> Note that old_b refer to the values and the method entry, while b refers to the value at the assertion point
> 
> 

Phase 2 is terminated. The outputted assertion will be saved inside `subjects\simple-examples_getMin\output\output.assertions`. More information of the run can also be found in the folder `subjects\simple-examples_getMin\output\`.

***
#### Phase 3 - evaluation of the resulting assertion

The final phase evaluates the final assertion with the mutation tool [PIT](https://pitest.org/) using the evaluation tests generated by Randoop during PHASE 1.

You should see PIT running

	================================================================================
	- Mutators
	================================================================================
	> org.pitest.mutationtest.engine.gregor.mutators.RemoveConditionalMutator_ORDER_ELSE
	>> Generated 3 Killed 1 (33%)
	> KILLED 1 SURVIVED 2 TIMED_OUT 0 NON_VIABLE 0 
	> MEMORY_ERROR 0 NOT_STARTED 0 STARTED 0 RUN_ERROR 0 
	> NO_COVERAGE 0 
	--------------------------------------------------------------------------------
	> org.pitest.mutationtest.engine.gregor.mutators.RemoveConditionalMutator_EQUAL_ELSE
	>> Generated 2 Killed 0 (0%)
	> KILLED 0 SURVIVED 2 TIMED_OUT 0 NON_VIABLE 0 
	> MEMORY_ERROR 0 NOT_STARTED 0 STARTED 0 RUN_ERROR 0 
	> NO_COVERAGE 0 
	--------------------------------------------------------------------------------


at the end you will see the mutation score of the final assertion

	total mutation 4 killed mutation 3 ratio .75000000000000000000
	assert((((old_a >= b) || (old_a == result)) && ((old_b > old_a) || (result == old_b))));

You can see information about the mutations killed/survived inside the `subjects/simple-examples_getMin/build/reports/pitest`.


Phase 3 is terminated. You can see more information about the result and the GASSERT run inside the `output` folder.


## Run with the other subjects

There are a total of 34 subjects that we used in our experiment. This is the complete list

	Angle_diff  
	Angle_getTurn  
	ArithmeticUtils_subAndCheck  
	Ascii_equalsIgnoreCase  
	BooleanUtils_compare  
	BooleanUtils_toBoolean  
	Complex_reciprocal  
	Conversion_hexDigitMsb0ToInt  
	Conversion_hexToShort  
	Envelope_maxExtent  
	FastMathNew_floor  
	IntMath_mod  
	LinearLocation_compareLocationValues  
	LongMath_saturatedMultiply  
	MathUtil_clamp  
	MathUtilsNew_copySignInt  
	QueueAr_dequeueAll  
	QueueAr_dequeue  
	QueueAr_enqueue  
	QueueAr_getFront  
	QueueAr_makeEmpty  
	StackAr_makeEmpty  
	StackAr_pop  
	StackAr_push  
	StackAr_topAndPop  
	StackAr_top  
	StringUtils_stripToNull  
	UnsignedInts_saturatedCast  
	Utf8_encodedLength  
	Vector2D_crossProduct   
	simple-examples_abs  
	simple-examples_addElementToSet  
	simple-examples_getMin  
	simple-examples_incrementNumberAtIndex  

For example, if you want to run subject `BooleanUtils_compare`, using RANDOM approach and initial assertion the invariant generated by daikon, 90 minutes time budget you can run as follows


For example:

	cd GAssert/scripts
	./run_gassert.sh RANDOM BooleanUtils_compare 90 daikon.assertions
	
## Prepare a new subject

You can prepare a new subject by following these instructions:

1. create a folder and put inside the folder `subjects`
2. be sure that it contains all the needed folders, to do so you can follow the provided template in `subjects/subjectName_methodName.zip`
3. be sure that the name of the folder subject contains the method name after the underscore. For example, if the method under analysis is called `foo`, the subject folder must be called `subjectName_foo.zip`
4. inside the subject folder must be the file `classname.input` with inside the fully qualified name of the class under test (e.g., `com.a.b.ClassA`).
5. Inside the subject folder there must be a folder called `orig` which contain the source code of the class under test with the assertion point specified by an `assert(true);` statement. 
6. The assertion in input must be specified in a separate file located in the folder `input-assertions`
7. If the initial assertion is in this form `assert(A && B && C);` please write the inner expression first one by one per line, and the second last line the entire assertion followed by an empty line. For example, if your assertion is `assert( (a>b) && (b!=0));` the file should contain the following:
	
	
		assert(a>b);  
		assert(b!=0);  
		assert((a>b) && (b!=0));  
	

8. GAssert needs gradle to compile the subject. Please follow the provided template. You can add your own dependencies. Be sure that PIT is properly configured with the right package name (targetClasses)

		pitest {
		    targetClasses = ['examples.*']  
		    threads = 1
		    outputFormats = ['XML', 'HTML']
		    jvmArgs = ['-ea']
		    timestampedReports = false
		    mutators = ["ALL"]
		}
	
	
	




